# check to ensure the above worked
getwd()
ele1_load <- readRDS("test/ele1.rds")
blockage_sf_load <- readRDS("test/blockage_sf.rds")
pipe_sf_load <- readRDS("test/pipe_sf.rds")
pipe_sf_load
blockage_sf_load
ele1_load
ele1_load2 <- st_as_sf(ele1_load,coords=c("Longitude","Latitude"))
ele1_load2 <- st_as_sf(na.omit(ele1_load),coords=c("Longitude","Latitude"))
st_crs(ele1_load2) <- 4326
ele1_load2
st_crs(ele1_load2) <- 27700
ele1_load2 <- st_as_sf(na.omit(ele1_load),coords=c("Longitude","Latitude"))
st_crs(ele1_load2) <- 4326
st_transform(ele1_load2, crs = 27700)
setwd("C:\\Users\\TOsosanya\\Desktop\\functions")
create("sfXtra")
# second step of creating the .rd of the functions in man folder
setwd("C:\\Users\\TOsosanya\\Desktop\\functions\\sfXtra\\R")
devtools::document()
#test the functions
setwd("C:\\Users\\TOsosanya\\Desktop\\functions")
cred <- git2r::cred_user_pass(rstudioapi::askForPassword("username"),
rstudioapi::askForPassword("Password"))
devtools::install_git("https://gitlab.com/tayoso/sfxtra.git",credentials = cred)
devtools::install_git("https://gitlab.com/tayoso2/sfxtra.git",credentials = cred)
# load the data
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(sfXtra)
# load the data
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# check to ensure the above worked
getwd()
ele1_load <- readRDS("test/ele1.rds")
blockage_sf_load <- readRDS("test/blockage_sf.rds")
pipe_sf_load <- readRDS("test/pipe_sf.rds")
## GetElevation()
GetElevation(x = ele1_load,AssetID = "Asset_Number",src = "aws")
ele1_load
## FindNearest()
FindNearest(blockage_sf_load,pipe_sf_load[1:10,])
## ConvertCoordinates
out1 <- east_north_to_long_lat(295189,305193)
out1
out2 <- long_lat_to_east_north(out1$long,out1$lat)
out2
out3 <- east_north_to_long_lat(out2$easting,out2$northing)
out3 #out3 and out1 should be same
#' position of a point on the Earth's surface
#' @param unit elevation unit in "meters" or "feet"
#' @param src this selects which API to use. "epqs"is best for  US only, "aws" for large number of points (>500)
#' @return Returns the same dataframe with the addition of the "elevation" column
#' @import sf
#' @import units
#' @import elevatr
#' @import magrittr
#' @import dplyr
#' @export
GetElevation <- function(x,
AssetID = "AssetID",
Longitude = "Longitude",
Latitude = "Latitude",
unit = "meters",
src = "epqs") {
# Accepts an asset with unique asset identifier, longitude and latitude to calculate elevation regardless
# of NAs in Latitude, Longitude columns.
#
# Returns:
#   The same dataframe with all rows and an additional "elevation" column.
#   This column represents the point elevation using x(long) and y(lat) as input.
#   Note that this object contains no geometry.
# convert unique id column name to standard "AssetID". Select the important colnames
colnames(x)[which(names(x) == AssetID)] <- "AssetID"
colnames(x)[which(names(x) == Longitude)] <- "Longitude"
colnames(x)[which(names(x) == Latitude)] <- "Latitude"
# extract the rows for which altitude cannot be calculated
if (isTRUE(mean(x$Latitude, na.rm = T)) < 180 & (mean(x$Longitude, na.rm = T) < 180)) {
y <- dplyr::select(x, AssetID, Longitude, Latitude) %>%
dplyr::mutate(Longitude = as.numeric(Longitude), Latitude = as.numeric(Latitude))
# use this to exclude rows without longitude and latitude
ele_na <- x %>% dplyr::filter(is.na(Longitude)) %>% dplyr::filter(is.na(Latitude)) %>% dplyr::select(AssetID, Longitude, Latitude)
ele <- x %>% dplyr::anti_join(ele_na, by = colnames(ele_na)[1])
#set crs to global 4326
ele <- st_as_sf(ele, coords = c("Longitude", "Latitude"), crs = 4326)
prj_dd <- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
# get_elev_point calculates the altitude
elevate <-
get_elev_point(ele,unit = "meters",prj = prj_dd, src = src)
output <- data.frame(elevate)
output$elev_units <- NULL; elevate <- NULL; ele_na <- NULL; output$geometry <- NULL
# merge both the new altitudes and original data using AssetID
output <- dplyr::inner_join(output, y, by = colnames(y)[1])
# revert unique id column name and other column names
colnames(output)[which(names(output) == "AssetID")] <- AssetID
colnames(output)[which(names(output) == "Longitude")] <- Longitude
colnames(output)[which(names(output) == "Latitude")] <- Latitude
return(output)
} else {
message("Error: Convert to WGS84 longlat")
}
}
ele1_load
## GetElevation()
GetElevation(x = ele1_load,AssetID = "Asset_Number",src = "aws")
# anonymise the data
ele1_load$Area <- "Company"
ele1_load <- ele1_load %>% select(Area, Asset_Number, Latitude, Longitude, StructureType,
Tower_Distance_From_Coast,Foundation_Reliability_Factor_Input,
Foundation_Reliability_Collar_Input,Foundation_Condition)
ele1_load$Asset_Number <- seq.int(nrow(ele1_load))
ele1_load
saveRDS(ele1_load, "C:/Users/TOsosanya/Desktop/ele1.rds")
ele1_load <- readRDS("test/ele1.rds")
ele1_load
## GetElevation()
GetElevation(x = ele1_load,AssetID = "Asset_Number",src = "aws")
#' position of a point on the Earth's surface
#' @param unit elevation unit in "meters" or "feet"
#' @param src this selects which API to use. "epqs"is best for  US only, "aws" for large number of points (>500)
#' @return Returns the same dataframe with the addition of the "elevation" column
#' @import sf
#' @import units
#' @import elevatr
#' @import magrittr
#' @import dplyr
#' @export
GetElevation <- function(x,
AssetID = "AssetID",
Longitude = "Longitude",
Latitude = "Latitude",
unit = "meters",
src = "epqs") {
# Accepts an asset with unique asset identifier, longitude and latitude to calculate elevation regardless
# of NAs in Latitude, Longitude columns.
#
# Returns:
#   The same dataframe with all rows and an additional "elevation" column.
#   This column represents the point elevation using x(long) and y(lat) as input.
#   Note that this object contains no geometry.
# convert unique id column name to standard "AssetID". Select the important colnames
colnames(x)[which(names(x) == AssetID)] <- "AssetID"
colnames(x)[which(names(x) == Longitude)] <- "Longitude"
colnames(x)[which(names(x) == Latitude)] <- "Latitude"
# extract the rows for which altitude cannot be calculated
if (isTRUE(mean(x$Latitude, na.rm = T)) < 180 & (mean(x$Longitude, na.rm = T) < 180)) {
y <- dplyr::select(x, AssetID, Longitude, Latitude) %>%
dplyr::mutate(Longitude = as.numeric(Longitude), Latitude = as.numeric(Latitude))
# use this to exclude rows without longitude and latitude
ele_na <- x %>% dplyr::filter(is.na(Longitude)) %>% dplyr::filter(is.na(Latitude)) %>% dplyr::select(AssetID, Longitude, Latitude)
ele <- x %>% dplyr::anti_join(ele_na, by = colnames(ele_na)[1])
#set crs to global 4326
ele <- st_as_sf(ele, coords = c("Longitude", "Latitude"), crs = 4326)
prj_dd <- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
# get_elev_point calculates the altitude
elevate <-
get_elev_point(ele,unit = "meters",prj = prj_dd, src = src)
output <- data.frame(elevate)
output$elev_units <- NULL; elevate <- NULL; ele_na <- NULL; output$geometry <- NULL
# merge both the new altitudes and original data using AssetID
output <- dplyr::inner_join(y, output, by = colnames(y)[1])
# revert unique id column name and other column names
colnames(output)[which(names(output) == "AssetID")] <- AssetID
colnames(output)[which(names(output) == "Longitude")] <- Longitude
colnames(output)[which(names(output) == "Latitude")] <- Latitude
return(output)
} else {
message("Error: Convert to WGS84 longlat")
}
}
## GetElevation()
GetElevation(x = ele1_load,AssetID = "Asset_Number",src = "aws")
#' position of a point on the Earth's surface
#' @param unit elevation unit in "meters" or "feet"
#' @param src this selects which API to use. "epqs"is best for  US only, "aws" for large number of points (>500)
#' @return Returns the same dataframe with the addition of the "elevation" column
#' @import sf
#' @import units
#' @import elevatr
#' @import magrittr
#' @import dplyr
#' @export
GetElevation <- function(x,
AssetID = "AssetID",
Longitude = "Longitude",
Latitude = "Latitude",
unit = "meters",
src = "epqs") {
# Accepts an asset with unique asset identifier, longitude and latitude to calculate elevation regardless
# of NAs in Latitude, Longitude columns.
#
# Returns:
#   The same dataframe with all rows and an additional "elevation" column.
#   This column represents the point elevation using x(long) and y(lat) as input.
#   Note that this object contains no geometry.
# convert unique id column name to standard "AssetID". Select the important colnames
colnames(x)[which(names(x) == AssetID)] <- "AssetID"
colnames(x)[which(names(x) == Longitude)] <- "Longitude"
colnames(x)[which(names(x) == Latitude)] <- "Latitude"
# extract the rows for which altitude cannot be calculated
if (isTRUE(mean(x$Latitude, na.rm = T)) < 180 & (mean(x$Longitude, na.rm = T) < 180)) {
y <- dplyr::select(x, AssetID, Longitude, Latitude) %>%
dplyr::mutate(Longitude = as.numeric(Longitude), Latitude = as.numeric(Latitude))
# use this to exclude rows without longitude and latitude
ele_na <- x %>% dplyr::filter(is.na(Longitude)) %>% dplyr::filter(is.na(Latitude)) %>% dplyr::select(AssetID, Longitude, Latitude)
ele <- x %>% dplyr::anti_join(ele_na, by = colnames(ele_na)[1])
#set crs to global 4326
ele <- st_as_sf(ele, coords = c("Longitude", "Latitude"), crs = 4326)
prj_dd <- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
# get_elev_point calculates the altitude
elevate <-
get_elev_point(ele,unit = "meters",prj = prj_dd, src = src)
output <- data.frame(elevate)
output$elev_units <- NULL; elevate <- NULL; ele_na <- NULL; output$geometry <- NULL
# merge both the new altitudes and original data using AssetID
output <- dplyr::select(AssetID,elevation)
output <- dplyr::left_join(y, output, by = colnames(y)[1])
# revert unique id column name and other column names
colnames(output)[which(names(output) == "AssetID")] <- AssetID
colnames(output)[which(names(output) == "Longitude")] <- Longitude
colnames(output)[which(names(output) == "Latitude")] <- Latitude
return(output)
} else {
message("Error: Convert to WGS84 longlat")
}
}
## GetElevation()
GetElevation(x = ele1_load,AssetID = "Asset_Number",src = "aws")
#' position of a point on the Earth's surface
#' @param unit elevation unit in "meters" or "feet"
#' @param src this selects which API to use. "epqs"is best for  US only, "aws" for large number of points (>500)
#' @return Returns the same dataframe with the addition of the "elevation" column
#' @import sf
#' @import units
#' @import elevatr
#' @import magrittr
#' @import dplyr
#' @export
GetElevation <- function(x,
AssetID = "AssetID",
Longitude = "Longitude",
Latitude = "Latitude",
unit = "meters",
src = "epqs") {
# Accepts an asset with unique asset identifier, longitude and latitude to calculate elevation regardless
# of NAs in Latitude, Longitude columns.
#
# Returns:
#   The same dataframe with all rows and an additional "elevation" column.
#   This column represents the point elevation using x(long) and y(lat) as input.
#   Note that this object contains no geometry.
# convert unique id column name to standard "AssetID". Select the important colnames
colnames(x)[which(names(x) == AssetID)] <- "AssetID"
colnames(x)[which(names(x) == Longitude)] <- "Longitude"
colnames(x)[which(names(x) == Latitude)] <- "Latitude"
# extract the rows for which altitude cannot be calculated
if (isTRUE(mean(x$Latitude, na.rm = T)) < 180 & (mean(x$Longitude, na.rm = T) < 180)) {
y <- dplyr::select(x, AssetID, Longitude, Latitude) %>%
dplyr::mutate(Longitude = as.numeric(Longitude), Latitude = as.numeric(Latitude))
# use this to exclude rows without longitude and latitude
ele_na <- x %>% dplyr::filter(is.na(Longitude)) %>% dplyr::filter(is.na(Latitude)) %>% dplyr::select(AssetID, Longitude, Latitude)
ele <- x %>% dplyr::anti_join(ele_na, by = colnames(ele_na)[1])
#set crs to global 4326
ele <- st_as_sf(ele, coords = c("Longitude", "Latitude"), crs = 4326)
prj_dd <- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
# get_elev_point calculates the altitude
elevate <-
get_elev_point(ele,unit = "meters",prj = prj_dd, src = src)
output <- data.frame(elevate)
output$elev_units <- NULL; elevate <- NULL; ele_na <- NULL; output$geometry <- NULL
# merge both the new altitudes and original data using AssetID
output <- dplyr::select(output,AssetID,elevation)
output <- dplyr::left_join(y, output, by = colnames(y)[1])
# revert unique id column name and other column names
colnames(output)[which(names(output) == "AssetID")] <- AssetID
colnames(output)[which(names(output) == "Longitude")] <- Longitude
colnames(output)[which(names(output) == "Latitude")] <- Latitude
return(output)
} else {
message("Error: Convert to WGS84 longlat")
}
}
## GetElevation()
GetElevation(x = ele1_load,AssetID = "Asset_Number",src = "aws")
#' position of a point on the Earth's surface
#' @param unit elevation unit in "meters" or "feet"
#' @param src this selects which API to use. "epqs"is best for  US only, "aws" for large number of points (>500)
#' @return Returns the same dataframe with the addition of the "elevation" column
#' @import sf
#' @import units
#' @import elevatr
#' @import magrittr
#' @import dplyr
#' @export
GetElevation <- function(x,
AssetID = "AssetID",
Longitude = "Longitude",
Latitude = "Latitude",
unit = "meters",
src = "epqs") {
# Accepts an asset with unique asset identifier, longitude and latitude to calculate elevation regardless
# of NAs in Latitude, Longitude columns.
#
# Returns:
#   The same dataframe with all rows and an additional "elevation" column.
#   This column represents the point elevation using x(long) and y(lat) as input.
#   Note that this object contains no geometry.
# convert unique id column name to standard "AssetID". Select the important colnames
colnames(x)[which(names(x) == AssetID)] <- "AssetID"
colnames(x)[which(names(x) == Longitude)] <- "Longitude"
colnames(x)[which(names(x) == Latitude)] <- "Latitude"
# extract the rows for which altitude cannot be calculated
if (isTRUE(mean(x$Latitude, na.rm = T)) < 180 & (mean(x$Longitude, na.rm = T) < 180)) {
y <- dplyr::select(x, AssetID, Longitude, Latitude) %>%
dplyr::mutate(Longitude = as.numeric(Longitude), Latitude = as.numeric(Latitude))
# use this to exclude rows without longitude and latitude
ele_na <- x %>% dplyr::filter(is.na(Longitude)) %>% dplyr::filter(is.na(Latitude)) %>% dplyr::select(AssetID, Longitude, Latitude)
ele <- x %>% dplyr::anti_join(ele_na, by = colnames(ele_na)[1])
#set crs to global 4326
ele <- st_as_sf(ele, coords = c("Longitude", "Latitude"), crs = 4326)
prj_dd <- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
# get_elev_point calculates the altitude
elevate <-
get_elev_point(ele,unit = "meters",prj = prj_dd, src = src)
output <- data.frame(elevate)
output$elev_units <- NULL; elevate <- NULL; ele_na <- NULL; output$geometry <- NULL
# merge both the new altitudes and original data using AssetID
output <- dplyr::select(output,AssetID,elevation)
output <- dplyr::full_join(y, output, by = colnames(y)[1])
# revert unique id column name and other column names
colnames(output)[which(names(output) == "AssetID")] <- AssetID
colnames(output)[which(names(output) == "Longitude")] <- Longitude
colnames(output)[which(names(output) == "Latitude")] <- Latitude
return(output)
} else {
message("Error: Convert to WGS84 longlat")
}
}
## GetElevation()
GetElevation(x = ele1_load,AssetID = "Asset_Number",src = "aws")
#' @param unit elevation unit in "meters" or "feet"
#' @param src this selects which API to use. "epqs"is best for  US only, "aws" for large number of points (>500)
#' @return Returns the same dataframe with the addition of the "elevation" column
#' @import sf
#' @import units
#' @import elevatr
#' @import magrittr
#' @import dplyr
#' @import plyr
#' @export
GetElevation <- function(x,
AssetID = "AssetID",
Longitude = "Longitude",
Latitude = "Latitude",
unit = "meters",
src = "epqs") {
# Accepts an asset with unique asset identifier, longitude and latitude to calculate elevation regardless
# of NAs in Latitude, Longitude columns.
#
# Returns:
#   The same dataframe with all rows and an additional "elevation" column.
#   This column represents the point elevation using x(long) and y(lat) as input.
#   Note that this object contains no geometry.
# convert unique id column name to standard "AssetID". Select the important colnames
colnames(x)[which(names(x) == AssetID)] <- "AssetID"
colnames(x)[which(names(x) == Longitude)] <- "Longitude"
colnames(x)[which(names(x) == Latitude)] <- "Latitude"
# extract the rows for which altitude cannot be calculated
if (isTRUE(mean(x$Latitude, na.rm = T)) < 180 & (mean(x$Longitude, na.rm = T) < 180)) {
y <- dplyr::select(x, AssetID, Longitude, Latitude) %>%
dplyr::mutate(Longitude = as.numeric(Longitude), Latitude = as.numeric(Latitude))
# use this to exclude rows without longitude and latitude
ele_na <- x %>% dplyr::filter(is.na(Longitude)) %>% dplyr::filter(is.na(Latitude)) %>% dplyr::select(AssetID, Longitude, Latitude)
ele <- x %>% dplyr::anti_join(ele_na, by = colnames(ele_na)[1])
#set crs to global 4326
ele <- st_as_sf(ele, coords = c("Longitude", "Latitude"), crs = 4326)
prj_dd <- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
# get_elev_point calculates the altitude
elevate <-
get_elev_point(ele,unit = "meters",prj = prj_dd, src = src)
output <- data.frame(elevate)
output$elev_units <- NULL; elevate <- NULL; ele_na <- NULL; output$geometry <- NULL
# merge both the new altitudes and original data using AssetID
# output <- dplyr::select(output,AssetID,elevation)
# output <- dplyr::full_join(y, output, by = colnames(y)[1])
output <- rbind.fill(output,ele_na)
# revert unique id column name and other column names
colnames(output)[which(names(output) == "AssetID")] <- AssetID
colnames(output)[which(names(output) == "Longitude")] <- Longitude
colnames(output)[which(names(output) == "Latitude")] <- Latitude
return(output)
} else {
message("Error: Convert to WGS84 longlat")
}
}
## GetElevation()
GetElevation(x = ele1_load,AssetID = "Asset_Number",src = "aws")
library(plyr)
## GetElevation()
GetElevation(x = ele1_load,AssetID = "Asset_Number",src = "aws")
#' @param unit elevation unit in "meters" or "feet"
#' @param src this selects which API to use. "epqs"is best for  US only, "aws" for large number of points (>500)
#' @return Returns the same dataframe with the addition of the "elevation" column
#' @import sf
#' @import units
#' @import elevatr
#' @import magrittr
#' @import dplyr
#' @import plyr
#' @export
GetElevation <- function(x,
AssetID = "AssetID",
Longitude = "Longitude",
Latitude = "Latitude",
unit = "meters",
src = "epqs") {
# Accepts an asset with unique asset identifier, longitude and latitude to calculate elevation regardless
# of NAs in Latitude, Longitude columns.
#
# Returns:
#   The same dataframe with all rows and an additional "elevation" column.
#   This column represents the point elevation using x(long) and y(lat) as input.
#   Note that this object contains no geometry.
# convert unique id column name to standard "AssetID". Select the important colnames
colnames(x)[which(names(x) == AssetID)] <- "AssetID"
colnames(x)[which(names(x) == Longitude)] <- "Longitude"
colnames(x)[which(names(x) == Latitude)] <- "Latitude"
# extract the rows for which altitude cannot be calculated
if (isTRUE(mean(x$Latitude, na.rm = T)) < 180 & (mean(x$Longitude, na.rm = T) < 180)) {
y <- dplyr::select(x, AssetID, Longitude, Latitude) %>%
dplyr::mutate(Longitude = as.numeric(Longitude), Latitude = as.numeric(Latitude))
# use this to exclude rows without longitude and latitude
ele_na <- x %>% dplyr::filter(is.na(Longitude)) %>% dplyr::filter(is.na(Latitude)) %>% dplyr::select(AssetID, Longitude, Latitude)
ele <- x %>% dplyr::anti_join(ele_na, by = colnames(ele_na)[1])
#set crs to global 4326
ele <- st_as_sf(ele, coords = c("Longitude", "Latitude"), crs = 4326)
prj_dd <- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
# get_elev_point calculates the altitude
elevate <-
get_elev_point(ele,unit = "meters",prj = prj_dd, src = src)
output <- data.frame(elevate)
output$elev_units <- NULL; elevate <- NULL; ele_na <- NULL; output$geometry <- NULL
# merge both the new altitudes and original data using AssetID
output <- dplyr::select(output,AssetID,elevation)
output <- dplyr::full_join(x, output, by = colnames(y)[1])
#output <- rbind.fill(output,ele_na)
# revert unique id column name and other column names
colnames(output)[which(names(output) == "AssetID")] <- AssetID
colnames(output)[which(names(output) == "Longitude")] <- Longitude
colnames(output)[which(names(output) == "Latitude")] <- Latitude
return(output)
} else {
message("Error: Convert to WGS84 longlat")
}
}
#' @param unit elevation unit in "meters" or "feet"
#' @param src this selects which API to use. "epqs"is best for  US only, "aws" for large number of points (>500)
#' @return Returns the same dataframe with the addition of the "elevation" column
#' @import sf
#' @import units
#' @import elevatr
#' @import magrittr
#' @import dplyr
#' @import plyr
#' @export
GetElevation <- function(x,
AssetID = "AssetID",
Longitude = "Longitude",
Latitude = "Latitude",
unit = "meters",
src = "epqs") {
# Accepts an asset with unique asset identifier, longitude and latitude to calculate elevation regardless
# of NAs in Latitude, Longitude columns.
#
# Returns:
#   The same dataframe with all rows and an additional "elevation" column.
#   This column represents the point elevation using x(long) and y(lat) as input.
#   Note that this object contains no geometry.
# convert unique id column name to standard "AssetID". Select the important colnames
colnames(x)[which(names(x) == AssetID)] <- "AssetID"
colnames(x)[which(names(x) == Longitude)] <- "Longitude"
colnames(x)[which(names(x) == Latitude)] <- "Latitude"
# extract the rows for which altitude cannot be calculated
if (isTRUE(mean(x$Latitude, na.rm = T)) < 180 & (mean(x$Longitude, na.rm = T) < 180)) {
y <- dplyr::select(x, AssetID, Longitude, Latitude) %>%
dplyr::mutate(Longitude = as.numeric(Longitude), Latitude = as.numeric(Latitude))
# use this to exclude rows without longitude and latitude
ele_na <- x %>% dplyr::filter(is.na(Longitude)) %>% dplyr::filter(is.na(Latitude)) %>% dplyr::select(AssetID, Longitude, Latitude)
ele <- x %>% dplyr::anti_join(ele_na, by = colnames(ele_na)[1])
#set crs to global 4326
ele <- st_as_sf(ele, coords = c("Longitude", "Latitude"), crs = 4326)
prj_dd <- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
# get_elev_point calculates the altitude
elevate <-
get_elev_point(ele,unit = "meters",prj = prj_dd, src = src)
output <- data.frame(elevate)
output$elev_units <- NULL; elevate <- NULL; ele_na <- NULL; output$geometry <- NULL
# merge both the new altitudes and original data using AssetID
output <- dplyr::select(output,AssetID,elevation)
output <- dplyr::full_join(x, output, by = colnames(y)[1])
#output <- rbind.fill(output,ele_na)
# revert unique id column name and other column names
colnames(output)[which(names(output) == "AssetID")] <- AssetID
colnames(output)[which(names(output) == "Longitude")] <- Longitude
colnames(output)[which(names(output) == "Latitude")] <- Latitude
return(output)
} else {
message("Error: Convert to WGS84 longlat")
}
}
## GetElevation()
GetElevation(x = ele1_load,AssetID = "Asset_Number",src = "aws")
