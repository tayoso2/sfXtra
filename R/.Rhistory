# Get decision bounds lengths
decision_bounds_lengths <- get_decision_bounds(x)$lengths
# Split decision stream into schemes and pumps
scheme_decisions <- decisions[1:decision_bounds_lengths[1]]
pump_decisions <-
decisions[decision_bounds_lengths[1] + 1:decision_bounds_lengths[2]]
# Apply scheme decisions
scheme_decisions <- round(scheme_decisions, 0)
selected_schemes <-
split(x$input$demand_reduction_schemes,
x$input$demand_reduction_schemes$area)
scheme_area_length <- lapply(selected_schemes, nrow)
scheme_area_decision_logicals <- lapply(scheme_area_length, logical)
set_to_true <- function(x, index){
x[index] <- TRUE
x
}
scheme_area_decision_logicals <- mapply(set_to_true,
x = scheme_area_decision_logicals,
index = scheme_decisions)
selected_schemes <- mapply(function(x, y) mutate(x, selected = y),
x = selected_schemes,
y = scheme_area_decision_logicals,
SIMPLIFY = FALSE
)
schemes_selected_summary <- selected_schemes %>%
bind_rows() %>%
mutate(selected = as.numeric(selected)) %>%
select(area, name, selected) %>%
gather(output_name, output_value, -area, -name)
selected_schemes <- selected_schemes %>%
bind_rows() %>%
filter(selected) %>%
select(-selected)
demand_schemes <- x$input$area_demand %>%
left_join(selected_schemes, by = "area") %>%
mutate(post_scheme_demand = demand + demand_reduction) %>%
select(area, name,  cost, post_scheme_demand) %>%
gather(output_name, output_value,-area,-name)
demand_schemes_summary <- demand_schemes %>%
group_by(area, output_name) %>%
summarise(output_value = sum(output_value))
# Calculate pump level outputs
pump_calc <- x$input$pump_details %>%
left_join(x$input$pump_costs, by = c("area", "pump")) %>%
# Add decisions
mutate(decision = pump_decisions) %>%
# Calculate costs
mutate(cost = pump_cost_intercept + decision ^ pump_cost_exp)
# pump_calc
pump_level_outputs <- pump_calc %>%
select(pump,
output = decision,
cost) %>%
mutate(cost_per_unit = cost / output) %>%
gather(output_name, output_value,-pump)
#pump_level_outputs
area_supply <- pump_calc %>%
group_by(area) %>%
summarise(total_supply = sum(decision)) %>%
ungroup()
headroom <- x$input$area_demand %>%
left_join(selected_schemes, by = "area") %>%
left_join(area_supply, by = "area") %>%
mutate(headroom = total_supply - (demand - demand_reduction)) %>%
select(area, headroom) %>%
gather(output_name, output_value,-area)
outputs <- list(headroom = headroom,
pump_level_outputs = pump_level_outputs,
schemes_selected_summary = schemes_selected_summary)
#outputs
}
# Test outputs are correct
(dev_evaluate(pump_optimisation, decisions))
# Add to genga
pump_optimisation <- add_evaluation_function(pump_optimisation, dev_evaluate)
pump_optimisation <- evaluate(pump_optimisation, decisions)
# Test evaluation
pump_optimisation <- evaluate(pump_optimisation, decisions)
pump_optimisation$output
sdb_pump_details
sdb_pump_costs
sdb_area_demand
sdb_demand_reduction_options
# Chunk 1
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
# Chunk 2: setup
library(genga)
library(tidyverse)
library(lubridate)
library(GA)
library(parallel)
library(doParallel)
# Chunk 3
pump_optimisation <- genga()
pump_optimisation
# Chunk 4
sdb_pump_details
sdb_pump_costs
sdb_area_demand
sdb_demand_reduction_options
pump_optimisation <-
add_input_data(pump_optimisation, sdb_pump_details, "pump_details")
pump_optimisation <-
add_input_data(pump_optimisation, sdb_pump_costs, "pump_costs")
pump_optimisation <-
add_input_data(pump_optimisation, sdb_area_demand, "area_demand")
pump_optimisation <-
add_input_data(pump_optimisation,
sdb_demand_reduction_options,
"demand_reduction_schemes")
pump_optimisation
# Chunk 5
make_pump_scheme_decisions <- function(x) {
pump_scheme_decisions <- x$input$demand_reduction_schemes %>%
group_by(area) %>%
summarise(total_available_schemes = n()) %>%
ungroup()
list(
upper = pump_scheme_decisions$total_available_schemes,
lower = rep(1, length(
pump_scheme_decisions$total_available_schemes
)),
decision_name = paste0(pump_scheme_decisions$area, "_demand_scheme")
)
}
pump_scheme_decisions <-
make_pump_scheme_decisions(pump_optimisation)
pump_scheme_decisions
make_pump_output_decisions <- function(x) {
upper <- x$input$pump_details$pump_max_output
lower <- x$input$pump_details$pump_min_output
decision_name <- x$input$pump_details$pump
list(upper = upper,
lower = lower,
decision_name = decision_name)
}
pump_output_decisions <-
make_pump_output_decisions(pump_optimisation)
pump_output_decisions
dev_decision_bounds <- function(x) {
pump_scheme_decisions <-
make_pump_scheme_decisions(pump_optimisation)
pump_scheme_decisions
pump_output_decisions <-
make_pump_output_decisions(pump_optimisation)
pump_output_decisions
# concat decisions
x <- list(pump_scheme_decisions,
pump_output_decisions)
concat_decisions(x)
}
dev_decision_bounds(pump_optimisation)
# Add to genga
pump_optimisation <-
add_decision_bound_function(pump_optimisation, dev_decision_bounds)
pump_optimisation
# Chunk 6
# Develop function to apply decisions and produce outputs
decisions <- make_random_decisions(pump_optimisation)
#decisions
dev_evaluate <- function(x, decisions) {
#browser()
# Get decision bounds lengths
decision_bounds_lengths <- get_decision_bounds(x)$lengths
# Split decision stream into schemes and pumps
scheme_decisions <- decisions[1:decision_bounds_lengths[1]]
pump_decisions <-
decisions[decision_bounds_lengths[1] + 1:decision_bounds_lengths[2]]
# Apply scheme decisions
scheme_decisions <- round(scheme_decisions, 0)
selected_schemes <-
split(x$input$demand_reduction_schemes,
x$input$demand_reduction_schemes$area)
scheme_area_length <- lapply(selected_schemes, nrow)
scheme_area_decision_logicals <- lapply(scheme_area_length, logical)
set_to_true <- function(x, index){
x[index] <- TRUE
x
}
scheme_area_decision_logicals <- mapply(set_to_true,
x = scheme_area_decision_logicals,
index = scheme_decisions)
selected_schemes <- mapply(function(x, y) mutate(x, selected = y),
x = selected_schemes,
y = scheme_area_decision_logicals,
SIMPLIFY = FALSE
)
schemes_selected_summary <- selected_schemes %>%
bind_rows() %>%
mutate(selected = as.numeric(selected)) %>%
select(area, name, selected) %>%
gather(output_name, output_value, -area, -name)
selected_schemes <- selected_schemes %>%
bind_rows() %>%
filter(selected) %>%
select(-selected)
demand_schemes <- x$input$area_demand %>%
left_join(selected_schemes, by = "area") %>%
mutate(post_scheme_demand = demand + demand_reduction) %>%
select(area, name,  cost, post_scheme_demand) %>%
gather(output_name, output_value,-area,-name)
demand_schemes_summary <- demand_schemes %>%
group_by(area, output_name) %>%
summarise(output_value = sum(output_value))
# Calculate pump level outputs
pump_calc <- x$input$pump_details %>%
left_join(x$input$pump_costs, by = c("area", "pump")) %>%
# Add decisions
mutate(decision = pump_decisions) %>%
# Calculate costs
mutate(cost = pump_cost_intercept + decision ^ pump_cost_exp)
# pump_calc
pump_level_outputs <- pump_calc %>%
select(pump,
output = decision,
cost) %>%
mutate(cost_per_unit = cost / output) %>%
gather(output_name, output_value,-pump)
#pump_level_outputs
area_supply <- pump_calc %>%
group_by(area) %>%
summarise(total_supply = sum(decision)) %>%
ungroup()
headroom <- x$input$area_demand %>%
left_join(selected_schemes, by = "area") %>%
left_join(area_supply, by = "area") %>%
mutate(headroom = total_supply - (demand - demand_reduction)) %>%
select(area, headroom) %>%
gather(output_name, output_value,-area)
outputs <- list(headroom = headroom,
pump_level_outputs = pump_level_outputs,
schemes_selected_summary = schemes_selected_summary)
#outputs
}
# Test outputs are correct
(dev_evaluate(pump_optimisation, decisions))
# Add to genga
pump_optimisation <- add_evaluation_function(pump_optimisation, dev_evaluate)
pump_optimisation <- evaluate(pump_optimisation, decisions)
# Test evaluation
pump_optimisation <- evaluate(pump_optimisation, decisions)
pump_optimisation$output
# Chunk 7
# Make blank config
opt_config <- make_blank_optimisation_config(pump_optimisation)
opt_config
# Set headroom targets
opt_config$headroom$target_value <- 0
opt_config$headroom$target_type <- "min"
opt_config$headroom$weight <- 100000
# Set goals to minimise costs
opt_config$pump_level_outputs <- opt_config$pump_level_outputs %>%
mutate(target_type = ifelse(output_name == "cost", "goal", NA),
weight = ifelse(output_name == "cost", 1, NA))
# Add config to genga
pump_optimisation <- add_optimisation_config(pump_optimisation, opt_config)
pump_optimisation
opt_config
pump_optimisation <- optimise(pump_optimisation,
#monitor = plot,
#parallel = 7,
maxiter = 10,
run = 250,
popSize = 50)
pump_optimisation$output
# Develop function to apply decisions and produce outputs
decisions <- make_random_decisions(pump_optimisation)
#decisions
dev_evaluate <- function(x, decisions) {
#browser()
# Get decision bounds lengths
decision_bounds_lengths <- get_decision_bounds(x)$lengths
# Split decision stream into schemes and pumps
scheme_decisions <- decisions[1:decision_bounds_lengths[1]]
pump_decisions <-
decisions[decision_bounds_lengths[1] + 1:decision_bounds_lengths[2]]
# Apply scheme decisions
scheme_decisions <- round(scheme_decisions, 0)
selected_schemes <-
split(x$input$demand_reduction_schemes,
x$input$demand_reduction_schemes$area)
scheme_area_length <- lapply(selected_schemes, nrow)
scheme_area_decision_logicals <- lapply(scheme_area_length, logical)
set_to_true <- function(x, index){
x[index] <- TRUE
x
}
scheme_area_decision_logicals <- mapply(set_to_true,
x = scheme_area_decision_logicals,
index = scheme_decisions)
selected_schemes <- mapply(function(x, y) mutate(x, selected = y),
x = selected_schemes,
y = scheme_area_decision_logicals,
SIMPLIFY = FALSE
)
schemes_selected_summary <- selected_schemes %>%
bind_rows() %>%
mutate(selected = as.numeric(selected)) %>%
select(area, name, selected) %>%
gather(output_name, output_value, -area, -name)
selected_schemes <- selected_schemes %>%
bind_rows() %>%
filter(selected) %>%
select(-selected)
demand_schemes <- x$input$area_demand %>%
left_join(selected_schemes, by = "area") %>%
mutate(post_scheme_demand = demand + demand_reduction) %>%
select(area, name,  cost, post_scheme_demand) %>%
gather(output_name, output_value,-area,-name)
demand_schemes_summary <- demand_schemes %>%
group_by(area, output_name) %>%
summarise(output_value = sum(output_value))
# Calculate pump level outputs
pump_calc <- x$input$pump_details %>%
left_join(x$input$pump_costs, by = c("area", "pump")) %>%
# Add decisions
mutate(decision = pump_decisions) %>%
# Calculate costs
mutate(cost = pump_cost_intercept + decision ^ pump_cost_exp)
# pump_calc
pump_level_outputs <- pump_calc %>%
select(pump,
output = decision,
cost) %>%
mutate(cost_per_unit = cost / output) %>%
gather(output_name, output_value,-pump)
#pump_level_outputs
area_supply <- pump_calc %>%
group_by(area) %>%
summarise(total_supply = sum(decision)) %>%
ungroup()
headroom <- x$input$area_demand %>%
left_join(selected_schemes, by = "area") %>%
left_join(area_supply, by = "area") %>%
mutate(headroom = total_supply - (demand - demand_reduction)) %>%
select(area, headroom) %>%
gather(output_name, output_value,-area)
outputs <- list(headroom = headroom,
pump_level_outputs = pump_level_outputs,
schemes_selected_summary = schemes_selected_summary)
#outputs
}
# Test outputs are correct
(dev_evaluate(pump_optimisation, decisions))
# Add to genga
pump_optimisation <- add_evaluation_function(pump_optimisation, dev_evaluate)
pump_optimisation <- evaluate(pump_optimisation, decisions)
# Test evaluation
pump_optimisation <- evaluate(pump_optimisation, decisions)
pump_optimisation$output
# Make blank config
opt_config <- make_blank_optimisation_config(pump_optimisation)
opt_config
# Set headroom targets
opt_config$headroom$target_value <- 0
opt_config$headroom$target_type <- "min"
opt_config$headroom$weight <- 100000
# Set goals to minimise costs
opt_config$pump_level_outputs <- opt_config$pump_level_outputs %>%
mutate(target_type = ifelse(output_name == "cost", "goal", NA),
weight = ifelse(output_name == "cost", 1, NA))
# Add config to genga
pump_optimisation <- add_optimisation_config(pump_optimisation, opt_config)
pump_optimisation
opt_config
pump_optimisation <- optimise(pump_optimisation,
#monitor = plot,
#parallel = 7,
maxiter = 10,
run = 250,
popSize = 50)
pump_optimisation$output
pump_optimisation
pump_optimisation$output
opt_config
opt_config$pump_level_outputs %>%
mutate(target_type = ifelse(output_name == "cost", "goal", NA),
weight = ifelse(output_name == "cost", 1, NA))
# Make blank config
opt_config <- make_blank_optimisation_config(pump_optimisation)
opt_config
# Set headroom targets
opt_config$headroom$target_value <- 0
opt_config$headroom$target_type <- "min"
opt_config$headroom$weight <- 100000
# Set goals to minimise costs
opt_config$pump_level_outputs <- opt_config$pump_level_outputs %>%
mutate(target_type = ifelse(output_name == "cost", "goal", NA),
weight = ifelse(output_name == "cost", 1, NA))
# Add config to genga
pump_optimisation <- add_optimisation_config(pump_optimisation, opt_config)
pump_optimisation
opt_config
library(dplyr)
library(tidyr)
library(data.table)
library(dplyr)
library(plyr)
library(sp)
library(sf)
library(raster)
library(maptools)
library(units)
library(tmap)
library(ggplot2)
library(rgdal)
library(gbm)
library(DescTools)
library(party)
library(caret)
library(tictoc)
library(purrr)
s24 <- st_read("G:\\Desktop\\STW PDaS\\S24 PDaS Filtered GIS\\STW_S24_Pipes.shp")
str(s24)
s24_confirmed <- s24 %>% filter(Pop_Dim == "A") %>%
filter(Pop_Mat == "A") %>%
filter(Pop_Yer != "C")
s24_confirmed <- s24_confirmed[!duplicated(s24_confirmed$Tag),]
summary(s24_confirmed)
s24_confirmed_1 <- as.data.frame(s24_confirmed) %>%
dplyr::select(Tag,County,Length,Tp_prps,Bndd_Mt,Bndd_Dm,Bndd_Yr,geometry) %>%
dplyr::rename(pipe_typ = Tp_prps) %>%
dplyr::rename(pipe_diam = Bndd_Dm) %>%
dplyr::rename(id = Tag) %>%
dplyr::rename(length = Length) %>%
dplyr::rename(pipe_mat = Bndd_Mt) %>%
dplyr::rename(Age = Bndd_Yr) %>%
mutate(Age = 2020 - as.numeric(as.character(Age)))
# s24_confirmed_2 <- s24_confirmed_1 %>%
#   mutate_at(c(3:5,7:8),as.character)
#deselct geomerty and transform length to factor
s24_confirmed_2 <- s24_confirmed_1 %>%
mutate(lengthband = as.factor(paste("band",round(length/20)))) %>%
mutate(Age = as.factor(Age)) %>%
dplyr::select(-length)
#split data for ML
set.seed(5)
train.base <- sample(1:nrow(s24_confirmed_2),(nrow(s24_confirmed_2)*0.85),replace = FALSE)
traindata.base <- s24_confirmed_2[train.base, ]
testdata.base <- s24_confirmed_2[-train.base, ]
traindata.base
str(traindata.base)
dplyr::select(-c(length,geometry)
)
# s24_confirmed_2 <- s24_confirmed_1 %>%
#   mutate_at(c(3:5,7:8),as.character)
#deselct geomerty and transform length to factor
s24_confirmed_2 <- s24_confirmed_1 %>%
mutate(lengthband = as.factor(paste("band",round(length/20)))) %>%
mutate(Age = as.factor(Age)) %>%
dplyr::select(-c(length,geometry))
s24_confirmed_2
#split data for ML
set.seed(5)
train.base <- sample(1:nrow(s24_confirmed_2),(nrow(s24_confirmed_2)*0.85),replace = FALSE)
traindata.base <- s24_confirmed_2[train.base, ]
testdata.base <- s24_confirmed_2[-train.base, ]
#cl <- makePSOCKcluster(6)
#registerDoParallel(cl) #start parallelisation
rf.fit3 <- cforest(pipe_diam ~ County + lengthband + Age, data = traindata.base, controls = cforest_unbiased(ntree = 50, mtry = 4))
rf.pred3 <- predict(rf.fit3,newdata = testdata.base, type = 'response')
caret::confusionMatrix(rf.pred3, testdata.base$pipe_diam)
cforestStats(rf.fit3)
####################################### Test confidence in old s24 ###################################################
s24 <- st_read("G:\\Desktop\\STW PDaS\\S24 PDaS Filtered GIS\\Joined S24\\Joined_S24.shp")
####################################### Test confidence in old s24 ###################################################
s24 <- st_read("I:\\Projects\\Client\\1883\\Analytics\\S24 PDaS Filtered GIS\\Joined S24\\Joined_S24.shp")
str(s24)
summary(s24)
s24_confirmed <- s24
s24_confirmed <- s24_confirmed[!duplicated(s24_confirmed$Tag),]
summary(s24_confirmed)
s24_confirmed %>% filter(Length > 100)
Address_2 <- st_read("I:\\Projects\\Client\\1883\\Analytics\\2020-03-10 TW Data\\ABP_PDaS\\Address\\Address.shp")
library(tidyr)
library(data.table)
library(dplyr)
library(plyr)
library(sp)
library(sf)
library(raster)
library(maptools)
library(units)
library(tmap)
library(ggplot2)
library(rgdal)
library(gbm)
library(DescTools)
library(party)
library(caret)
library(tictoc)
library(purrr)
Address_2 <- st_read("I:\\Projects\\Client\\1883\\Analytics\\2020-03-10 TW Data\\ABP_PDaS\\Address\\Address.shp")
Historic_2 <- st_read("I:\\Projects\\Client\\1883\\Analytics\\2020-03-10 TW Data\\ABP_PDaS\\Historic Address\\HistoricAddress.shp")
Historic_2
setwd("C:\\Users\\TOsosanya\\Desktop\\functions\\sfXtra\\R")
#test the functions
setwd("C:\\Users\\TOsosanya\\Desktop\\functions")
devtools::install("sfXtra")
#install.packages("sfXtra")
library(sfXtra)
setwd("C:\\Users\\TOsosanya\\Desktop\\Electricity\\PGE\\tower")
ele1 <- read.csv("steel.asset.base.cleansed.csv")
ele1 <- ele1[1:100,]
GetElevation(x = ele1,AssetID = "Asset_Number")
GetElevation(x = ele1,AssetID = "Asset_Number",src = "aws")
setwd("C:\\Users\\TOsosanya\\Desktop\\functions\\sfXtra\\R")
devtools::document()
